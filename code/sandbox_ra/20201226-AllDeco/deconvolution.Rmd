---
title: "Cell type deconvolution"
author: "RA ([numpde](https://github.com/numpde/))"
date: "2020-Dec-26"
output: 
  html_document:
    toc: true
    toc_depth: 2
editor_options:
 chunk_output_type: console
---


## Introduction

We investigate
a dataset of 102 bulk [RNA-seq](https://en.wikipedia.org/wiki/RNA-Seq) samples
extracted from the prefrontal cortex
of 102 deceased individuals
([overview](https://github.com/numpde/sta426_deconvo/tree/main/code/sandbox_ra/20201130-FirstLook)).
The dataset is provided by 
H Rehrauer of FGCZ
([details](https://github.com/numpde/sta426_deconvo/tree/main/data/20201128-FGCZ)).
Roughly half of the samples are
from patients diagnosed with 
[ALS](https://en.wikipedia.org/wiki/Amyotrophic_lateral_sclerosis),
the remaining ones are referred to as the control group.
We attempt to infer 
cell type proportions
hidden in each bulk RNA-seq sample.
This procedure,
known as cell type deconvolution
([overview](https://bit.ly/sta426_deconvo_sketch)),
should be integral to
inference from the sample to disease condition.
We focus here on reference-based deconvolution:
in essence,
if $X$ is a bulk RNA-seq count vector,
and $a, b, \ldots$
are single-cell RNA-seq count vectors of
representatives of relevant cells types,
one aims to find non-negative coefficients
$\alpha, \beta, \ldots$
such that
$X \approx \alpha a + \beta b + \ldots$.
Unfortunately,
this reconstruction
is confounded by 
batch effects
such as difference in sequencing platforms,
in particular
different statistical properties of 
the technical noise 
of bulk versus single-cell RNA-seq.

As single-cell RNA (scRNA) cell type reference datasets we resort to
[Darmanis et al](https://github.com/numpde/sta426_deconvo/tree/main/data/20201206-RefDatasets/2015-Darmanis)
(about 400 cells)
and
[Allen Brain M1](https://github.com/numpde/sta426_deconvo/tree/main/data/20201206-RefDatasets/2019-AllenBrain-M1)
(>70k cells).
The two are compared 
[here](https://github.com/numpde/sta426_deconvo/tree/main/code/sandbox_ra/20201220-Darmanis_vs_Allen).
Note that Allen Brain M1 is from 
[snRNA-seq](https://en.wikipedia.org/wiki/SnRNA-seq).

**(in progress)**


#### Pertinent links

- [Source code](https://github.com/numpde/sta426_deconvo/tree/main/code/sandbox_ra/20201226-AllDeco),
  [output folder](https://github.com/numpde/sta426_deconvo/tree/main/code/sandbox_ra/20201226-AllDeco/output) of this script.


- Bisque 
  [paper](https://www.nature.com/articles/s41467-020-15816-6),
  [vignette](https://cran.r-project.org/web/packages/BisqueRNA/vignettes/bisque.html),
  [manual](https://cran.r-project.org/web/packages/BisqueRNA/BisqueRNA.pdf),
  [github](https://github.com/cozygene/bisque),
  [ReferenceBasedDecomposition](https://rdrr.io/cran/BisqueRNA/src/R/reference_based.R)
  (uses 
  [limSolve](https://cran.r-project.org/web/packages/limSolve/limSolve.pdf)).

- MuSiC
  [paper](https://www.nature.com/articles/s41467-018-08023-x),
  [tutorial](https://xuranw.github.io/MuSiC/articles/MuSiC.html),
  [github](https://github.com/xuranw/MuSiC),
  [music_prop](https://rdrr.io/github/xuranw/MuSiC/src/R/utils.R).



## Preliminaries {.tabset .tabset-fade .tabset-pills}

### Setup    

```{r setup, include=TRUE}
suppressPackageStartupMessages({
  requireNamespace("magrittr")
  library(dplyr)
  library(ggplot2)

  requireNamespace("pheatmap")
  requireNamespace("stringr")
  requireNamespace("reshape2")

  # avoid importing `exprs` that leads to clashes
  requireNamespace("rlang")

  # https://vroom.r-lib.org/articles/vroom.html
  # install.packages("vroom")
  requireNamespace("vroom")

  # install.packages("pathlibr")
  requireNamespace("pathlibr")

  # Provides `ExpressionSet` data structure
  # BiocManager::install("Biobase")
  requireNamespace("Biobase")

  # Deconvolution package
  # install.packages("BisqueRNA")
  requireNamespace("BisqueRNA")

  # # https://xuranw.github.io/MuSiC/articles/MuSiC.html
  # install.packages("devtools")
  # devtools::install_github("xuranw/MuSiC")
  requireNamespace("xbioc") # For MuSiC
  requireNamespace("MuSiC")

  # install.packages("kableExtra")
  requireNamespace("kableExtra")
})
```


### Session info

```{r, echo=FALSE}
sessionInfo()
```


### Paths

```{r}
BASEPATH <- pathlibr::Path$new(".")
stopifnot("deconvolution.Rmd" %in% names(BASEPATH$dir))
```

```{r}
out_file <- (function(.) BASEPATH$join("output")$join(.)$show)
dir.create(out_file(""), showWarnings = FALSE)
```

```{r}
path_to <- (function(.) Sys.glob(BASEPATH$join("../../..")$join(.)$show))
```

### Random-seed

```{r}
set.seed(43)
```

### Row names, etc.

```{r}
# Use first column as index
by_col1 <- (function(.) tibble::column_to_rownames(., colnames(.)[1]))
# Use index as new column `name`
ind2col <- (function(., name) tibble::rownames_to_column(., var = name))
```

```{r}
group_by_and_sum <-
  function(., column_name) {
    (.) %>%
      dplyr::group_by(!!rlang::sym(column_name)) %>%
      dplyr::summarise_all(sum) %>%
      tibble::column_to_rownames(column_name)
  }
```

```{r}
fix_names <- function(.) {
  (.) %>%
    # https://stackoverflow.com/a/55184433
    rlang::set_names(stringr::str_replace(names(.), "cell type", "celltype"))
}
```

```{r}
col_norm2 <- (function(.) t(t(.) / sqrt(colSums((.)**2))))
```

### File I/O

The function `utils::read.delim` is too slow
to read wide tables (Allen Brain M1 has >70k cells).

```{r}
Sys.setenv("VROOM_CONNECTION_SIZE" = 131072 * 32)
from_csv <- function(.) {
  vroom::vroom(., del = "\t") %>%
    by_col1() %>%
    suppressMessages()
}
```

A call to `to_csv` should be preceded by
`ind2col("name for index")`
to write the row names.

```{r}
to_csv <- function(., f) {
  vroom::vroom_write(., out_file(f), delim = "\t")
}
```

### Plotting

```{r}
ggplot2::theme_set(theme_light(base_size = 15))
```

```{r}
kable <- function(.) {
  kableExtra::kbl(., align = "c") %>%
    kableExtra::kable_paper("hover", full_width = F)
}
```

```{r}
# Wide plots (inches?)
WIDTH1 <- 20
HEIGHT1 <- 3
```

```{r}
hist_theme <-
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
  )
```

```{r}
save_barchart <-
  function(., filename) {
    as.data.frame(.) %>%
      ind2col("celltype") %>%
      reshape2::melt(
        id = "celltype",
        var = "sample",
        value.name = "y"
      ) %>%
      {
        ggplot(., aes(x = sample, y = y, fill = celltype)) +
          geom_bar(stat = "identity") +
          scale_fill_brewer(palette = "Paired") +
          ylim(0, 1) +
          hist_theme +
          theme(
            legend.title = element_blank(),

            axis.text.y = element_blank(),

            axis.title.x = element_blank(),
            axis.text.x = element_text(
              a = -90,
              vjust = 0.5,
              hjust = 0,
              size = 10,
            )
          ) +
          ggsave(
            filename = out_file(filename),
            width = WIDTH1,
            height = HEIGHT1,
            device = "png"
          )
      } %>%
      suppressWarnings()
    return(.)
  }
```

```{r}
save_heatmap <-
  function(., filename) {
    as.data.frame(.) %>%
      pheatmap::pheatmap(
        filename = out_file(filename),
        cluster_rows = FALSE,
        cluster_cols = FALSE,
        fontsize_row = 14,
        fontsize_col = 10,
        width = WIDTH1,
        height = HEIGHT1
      )
    return(.)
  }
```





## Data sources {.tabset .tabset-fade .tabset-pills}


### Bulk expression: FGCZ

```{r, cache=TRUE}
fgcz_data <-
  path_to("data/20201128-FGCZ/*count.zip") %>%
  unz(., unzip(., list = TRUE)$Name) %>%
  from_csv() %>%
  # Collapse ENSG IDs by gene_name:
  group_by_and_sum("gene_name")

fgcz_meta <- from_csv(path_to("data/20201128-FGCZ/*infos.tsv"))
```

This will be used later.

```{r}
assert_fgcz_meta_order <-
  function(.) {
    stopifnot(all(rownames(.) == rownames(fgcz_meta)))
    return(.)
  }
```

```{r}
t(fgcz_data) %>%
  assert_fgcz_meta_order() %>%
  invisible()
```

### Ref scRNA: Darmanis

```{r, cache=TRUE}
darm_data <- from_csv(path_to("data/*/2015-Darmanis/b*/data.csv.gz"))
darm_meta <- from_csv(path_to("data/*/2015-Darmanis/b*/meta.csv.gz")) %>%
  fix_names()
```

```{r}
exclude_celltypes <- c("fetal_quiescent", "fetal_replicating", "hybrid")
```

Plot cell type counts.

```{r}
darm_meta$celltype %>%
  data.frame(x = .) %>%
  ggplot(aes(x = x, fill = if_else(x %in% exclude_celltypes, "drop", "keep"))) +
  geom_bar() +
  ggtitle("Cell types in the 'Darmanis' reference dataset") +
  scale_y_log10() +
  hist_theme +
  theme(axis.title.x = element_blank()) +
  theme(axis.text.x = element_text(a = 45, hjust = 1)) +
  theme(legend.title = element_blank())
```

Remove unnecessary cell types
from the scRNA reference dataset.

```{r, cache=TRUE}
darm_meta <-
  darm_meta %>%
  dplyr::filter(!(celltype %in% exclude_celltypes))

darm_data <-
  darm_data %>%
  dplyr::select_if(names(.) %in% rownames(darm_meta))

stopifnot(285 == nrow(darm_meta))
stopifnot(285 == ncol(darm_data))
```


### Ref scRNA: Allen Brain M1

```{r, cache=TRUE}
abm1_meta <- from_csv(path_to("data/*/2019-AllenBrain-M1/b*/meta.csv*"))
abm1_data <- from_csv(path_to("data/*/2019-AllenBrain-M1/b*/data.csv*"))
```

Some sanity checks.

```{r}
# Number of single cells
stopifnot(ncol(abm1_data) > 70000)
stopifnot(nrow(abm1_meta) > 70000)
# Number of genes and some examples
stopifnot(nrow(abm1_data) == 141)
stopifnot(all(c("PIK3CD", "WNT4", "LDLRAP1") %in% rownames(abm1_data)))
```

Drop samples with too little expression,
otherwise Bisque doesn't go through.

```{r, cache=TRUE}
abm1_data <-
  abm1_data %>%
  # Keep only genes common with the FGCZ dataset
  {
    (.)[rownames(.) %in% rownames(fgcz_data), ]
  } %>%
  # Drop zero columns (dplyr variant too slow)
  {
    (.)[, colSums(.) != 0]
  }

abm1_meta <-
  abm1_meta %>%
  dplyr::filter(rownames(.) %in% colnames(abm1_data))
```

Plot cell type counts.

```{r}
data.frame(
  x = abm1_meta$celltype,
  donor = abm1_meta$donor
) %>%
  ggplot(aes(x = x, fill = donor)) +
  geom_bar(position = "dodge") +
  ggtitle("Cell types in the 'Allen Brain M1' reference dataset") +
  scale_fill_brewer(palette = "Set1") +
  scale_y_log10() +
  hist_theme +
  theme(axis.title.x = element_blank()) +
  theme(axis.title.y = element_blank())
```


### Marker genes

These marker genes 
[were extracted](https://github.com/numpde/sta426_deconvo/tree/main/data/20201206-RefDatasets/2019-AllenBrain-M1)
from the
[Allen Brain M1](https://portal.brain-map.org/atlases-and-data/rnaseq/human-m1-10x)
scRNA dataset.
Technically, these should be the same as 
in `abm1_data` before filtering.
Just in case, we subset them the maximal common subset.


```{r, cache=TRUE}
abm1_markergenes <-
  path_to("data/*/*AllenBrain-M1/b*/marker_genes.csv") %>%
  from_csv() %>%
  rownames() %>%
  {
    (.)[(.) %in% rownames(fgcz_data)]
  } %>%
  {
    (.)[(.) %in% rownames(abm1_data)]
  }

stopifnot(117 == length(abm1_markergenes))
```



## Deconvolution


### From Darmanis {.tabset .tabset-fade .tabset-pills}

In this section we use
**Darmanis et al**
as the reference dataset.

#### Bisque {#fgcz_darm_bisque}

Repackage the data
following the 
[Bisque vignette](https://cran.r-project.org/web/packages/BisqueRNA/vignettes/bisque.html).

```{r}
fgcz_eset <- Biobase::ExpressionSet(
  # Subset to marker genes for residual norm computation
  assayData = as.matrix(fgcz_data[abm1_markergenes, ])
)
```

```{r}
darm_eset <- Biobase::ExpressionSet(
  # Expression data
  assayData = as.matrix(darm_data),
  # Metadata
  phenoData = Biobase::AnnotatedDataFrame(
    data = data.frame(
      row.names = rownames(darm_meta),
      cellType = darm_meta$celltype,
      SubjectName = darm_meta$experiment_sample_name,
      check.names = FALSE,
      check.rows = FALSE,
      stringsAsFactors = FALSE
    ),
    varMetadata = data.frame(
      row.names = c("cellType", "SubjectName"),
      labelDescription = c("cellType", "SubjectName")
    )
  )
)
```

Deconvolution.

```{r, cache=TRUE}
bisque_report <-
  BisqueRNA::ReferenceBasedDecomposition(
    # BULK DATA
    bulk.eset = fgcz_eset,
    # REFERENCE
    sc.eset = darm_eset,
    #
    use.overlap = FALSE,
    markers = abm1_markergenes,
    verbose = FALSE
  )
```

```{r}
# Fields of the Bisque result
bisque_report %>%
  summary() %>%
  kable()
```


Bisque returns proportions 
that sum to one:

```{r}
stopifnot(max(abs(1 - colSums(bisque_report$bulk.props))) <= 1e-10)
```

We undo that using the residual.
The meaning of `rnorm` is not clear
from the
[manual](https://cran.r-project.org/web/packages/BisqueRNA/BisqueRNA.pdf),
so this might be incorrect:

```{r}
explained_fractions <-
  bisque_report %>% {
    1 - (sqrt((.)$rnorm) / sqrt(colSums(fgcz_data[(.)$genes.used, ]**2)))
  }
```

Rescale proportions to 
the "explained fractions".

```{r}
fgcz_darm_bisque <-
  t(t(bisque_report$bulk.props) * explained_fractions)
```

Cluster bulk samples by composition.

```{r}
samples_order <-
  fgcz_darm_bisque %>%
  {
    (.)[, hclust(dist(t(.)))$order]
  } %>%
  colnames()
```

Save to disk
and
visualize inferred cell type composition
by bulk sample.

```{r}
visualize_and_save <-
  function(., prefix = deparse(substitute(.))) {
    as <- {
      function(ext) paste(prefix, ext, sep = "_")
    }

    (.)[, samples_order] %>%
      #
      save_heatmap(as("heat.png")) %>%
      save_barchart(as("bars.png")) %>%
      #
      as.data.frame() %>%
      ind2col("celltype") %>%
      to_csv(as("data.csv"))
  }
```

```{r}
visualize_and_save(fgcz_darm_bisque)
```

![](`r out_file("fgcz_darm_bisque_heat.png")`)
![](`r out_file("fgcz_darm_bisque_bars.png")`)


The cell type proportions [returned by Bisque](#fgcz_darm_bisque)
vary rather more than expected.
The samples come from four
different hospitals 
(the field `fgcz_meta$Source`),
which could introduce the strongest batch effect.
We can also compare that 
to the [RIN](https://en.wikipedia.org/wiki/RNA_integrity_number)
(RNA integrity number).
Age could be another important factor.

```{r}
PC1_versus <-
  function(., on_the_y_axis) {
    prcomp(t(.))$x %>%
      as.data.frame() %>%
      assert_fgcz_meta_order() %>%
      cbind(fgcz_meta) %>%
      cbind(q = (2 * rank((.)$PC1) / length((.)$PC1) - 1)) %>%
      cbind(y = (.)[[on_the_y_axis]]) %>%
      {
        ggplot(., aes(x = q, y = y, shape = Condition, color = Source)) +
          labs(
            x = "Deviation from the average composition (~PC1)",
            y = on_the_y_axis,
            color = "Sample source",
            shape = "Condition"
          ) +
          geom_point(size = 5, alpha = 0.2 + abs((.)$q)) +
          scale_color_brewer(palette = "Set1")
      }
  }
```

Principal components of cell type proportions.

```{r}
fgcz_darm_bisque %>%
  PC1_versus("PC2")
```

```{r}
fgcz_darm_bisque %>%
  PC1_versus("RIN")
```

```{r}
fgcz_darm_bisque %>%
  PC1_versus("Age")
```



#### MuSiC

```{r, cache=TRUE}
# Prevent errors from MuSiC
exprs <- xbioc::exprs
pVar <- xbioc::pVar

music_report.darm <-
  MuSiC::music_prop(
    bulk.eset = fgcz_eset,
    sc.eset = darm_eset,
    clusters = darm_meta$celltype,
    samples = names(darm_data)
  ) %>%
  suppressMessages()
```

```{r}
music_report.darm %>%
  summary() %>%
  kable()
```

Estimate cell type proportions (celltype x sample).

```{r}
fgcz_darm_music <-
  t(music_report.darm$Est.prop.weighted) %>% {
    (.)[rownames(fgcz_darm_bisque), ]
  }
```

```{r}
visualize_and_save(fgcz_darm_music)
```

![](`r out_file("fgcz_darm_music_heat.png")`)
![](`r out_file("fgcz_darm_music_bars.png")`)

Principal components of cell type proportions.

```{r}
fgcz_darm_music %>%
  PC1_versus("PC2")
```

```{r}
fgcz_darm_music %>%
  PC1_versus("RIN")
```

```{r}
fgcz_darm_music %>%
  PC1_versus("Age")
```

We would like to know
whether there is 
the cell type composition differs 
in ALS vs Control samples.
First,
the following figure shows the distribution
of the first principal component
(of cell type proportions)
separated by sample source.

```{r}
fgcz_darm_music.pca <-
  fgcz_darm_music %>%
  {
    as.data.frame(prcomp(t(.))$x)
  } %>%
  assert_fgcz_meta_order() %>%
  cbind(fgcz_meta)
```

```{r, eval=TRUE}
fgcz_darm_music.pca %>% {
  ggplot(., aes(x = PC1, fill = Source, linetype = Source)) +
    labs(fill = "Sample source") +
    guides(linetype = FALSE) +
    geom_density(
      position = "identity", alpha = 0.4
    ) +
    geom_histogram(
      aes(y = stat(density) / 5),
      position = "dodge", bins = 20, color = 1, linetype = 1
    ) +
    hist_theme +
    theme(axis.text.y = element_blank()) +
    theme(
      panel.grid.major.y = element_blank(),
      panel.grid.minor.y = element_blank(),
    ) +
    scale_fill_brewer(palette = "Set1")
}
```

The separation by **Source**
seen in the above figure 
suggests looking at 
the **Condition** (ALS vs Control)
for each **Source** individually.

```{r}
fgcz_darm_music.pca %>%
  {
    ggplot(., aes(x = PC1, fill = Condition)) +
      geom_density(
        position = "identity", alpha = 0.4
      ) +
      geom_histogram(
        aes(y = stat(density) / 5),
        position = "dodge", bins = 20, color = 1, linetype = 1
      ) +
      hist_theme +
      theme(
        axis.text.x = element_blank(),
        axis.text.y = element_blank()
      ) +
      scale_fill_brewer(palette = "Set1") +
      facet_grid(cols = vars(Source))
  } %>%
  ggsave(
    filename = out_file("fgcz_darm_music_PC1.png"),
    width = WIDTH1,
    height = WIDTH1 / 4
  ) %>%
  invisible()
```

![](`r out_file("fgcz_darm_music_PC1.png")`)


Among those,
samples from **Lo**
show a conspicuous further separation 
by **Condition**,
supported by the following 
two-sided two-sample t-test.

```{r}
fgcz_darm_music.pca %>%
  filter(Source != "PD") %>%
  group_by(Source) %>%
  group_map(~ {
    t.test(
      x = filter((.x), Condition == "ALS")$PC1,
      y = filter((.x), Condition != "ALS")$PC1,
      alternative = "two"
    ) %>% {
      list(
        `Sample source` = dplyr::pull((.y)),
        `p-value` = round((.)$p.value, 3),
        `t-statistic` = round((.)$statistic, 2),
        `#dof` = round((.)$parameter, 1)
      )
    }
  }) %>%
  data.table::rbindlist() %>%
  kable()
```

```{r, eval=FALSE, echo=FALSE}
# Permutation tests

# install.packages("exactRankTests")
requireNamespace("exactRankTests")

# install.packages("DAAG")
requireNamespace("DAAG")
```


#### Baseline NNLS

For the code see 
[here](https://github.com/numpde/sta426_deconvo/blob/main/code/sandbox_ra/20201206-NNLS_Darmanis/a_deconvolution0.py).

```{r}
fgcz_darm_nnls <-
  path_to("code/*/*-NNLS_Darmanis/a_*/celltypes.csv") %>%
  # The first column is not unique
  # Keep header as is, e.g. "H-0C083"
  utils::read.delim(., check.names = F) %>%
  # `cell type` ~> `celltype`
  fix_names() %>%
  # Collapse cell types:
  group_by_and_sum("celltype")
```

```{r}
visualize_and_save(fgcz_darm_nnls)
```

![](`r out_file("fgcz_darm_nnls_heat.png")`)
![](`r out_file("fgcz_darm_nnls_bars.png")`)


```{r}
fgcz_darm_nnls %>%
  PC1_versus("PC2")
```

```{r}
fgcz_darm_nnls %>%
  PC1_versus("RIN")
```

```{r}
fgcz_darm_nnls %>%
  PC1_versus("Age")
```


These results are similar enough to MuSiC's
to warrant a closer look.
For each sample we compute the cosine similarity
between the two methods
and plot a histogram of those
separated by sample source.

```{r}
# Check that samples are arranged consistently
stopifnot(all(colnames(fgcz_darm_music) == colnames(fgcz_darm_nnls)))
stopifnot(all(rownames(fgcz_darm_music) == rownames(fgcz_darm_nnls)))

colSums(col_norm2(fgcz_darm_music) * col_norm2(fgcz_darm_nnls)) %>%
  data.frame(
    x = .,
    s = fgcz_meta$Source
  ) %>%
  {
    ggplot(., aes(x = x, fill = s, linetype = s)) +
      labs(fill = "Sample source") +
      labs(x = "Cosine similarity of a sample (NNLS vs MuSiC)") +
      guides(linetype = FALSE) +
      geom_density(
        position = "identity", alpha = 0.4
      ) +
      geom_histogram(
        aes(y = stat(density) / 5),
        position = "dodge", bins = 30, color = 1, linetype = 1,
      ) +
      hist_theme +
      theme(axis.text.y = element_blank()) +
      theme(
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
      ) +
      scale_fill_brewer(palette = "Set1")
  }
```



### From Allen Brain M1 {.tabset .tabset-fade .tabset-pills}

In this section we use
**Allen Brain M1**
as the reference dataset.

#### Bisque

Repackage:

```{r, eval=FALSE, echo=FALSE}
# # HACK
# a <- unique(abm1_meta$donor)[1]
# b <- unique(abm1_meta$donor)[2]
# a <- rownames(abm1_meta[abm1_meta$donor == a, ])[1:10]
# b <- rownames(abm1_meta[abm1_meta$donor == b, ])[1:10]
# s <- c(a, b)
# abm1_meta <- abm1_meta[s, ]
# abm1_data <- abm1_data[, s]
```

```{r}
abm1_eset <- Biobase::ExpressionSet(
  # Expression data
  assayData = as.matrix(abm1_data),
  # Metadata
  phenoData = Biobase::AnnotatedDataFrame(
    data = data.frame(
      row.names = rownames(abm1_meta),
      cellType = abm1_meta$celltype,
      SubjectName = abm1_meta$donor,
      check.names = FALSE,
      check.rows = FALSE
    ),
    varMetadata = data.frame(
      row.names = c("cellType", "SubjectName"),
      labelDescription = c("cellType", "SubjectName")
    )
  )
)
```

Deconvolution:

```{r, cache=TRUE}
bisque_report <-
  BisqueRNA::ReferenceBasedDecomposition(
    # BULK DATA
    bulk.eset = fgcz_eset,
    # REFERENCE
    sc.eset = abm1_eset,
    #
    use.overlap = FALSE,
    markers = abm1_markergenes,
    verbose = FALSE
  )
```

```{r}
bisque_report$bulk.props %>%
  visualize_and_save("fgcz_abm1_bisque")
```

![](`r out_file("fgcz_abm1_bisque_heat.png")`)
![](`r out_file("fgcz_abm1_bisque_bars.png")`)


#### MuSiC

**(this subsection is in progress)**

```{r, eval=F, cache=TRUE}
stopifnot(!file.exists(out_file("fgcz_abm1_music.csv")))

# MuSiC with ABM1
music_report.abm1 <-
  MuSiC::music_prop(
    bulk.eset = fgcz_eset,
    sc.eset = abm1_eset,
    clusters = abm1_meta$celltype,
    samples = names(abm1_data)
  ) %>%
  suppressMessages()
```

```{r, eval=F}
fgcz_abm1_music <-
  t(music_report.abm1$Est.prop.weighted)
```

```{r, eval=F}
fgcz_abm1_music %>%
  visualize_and_save("fgcz_abm1_music")
```

```{r}
# ![](`r out_file("fgcz_abm1_music_heat.png")`)
# ![](`r out_file("fgcz_abm1_music_bars.png")`)
```



## Acknowledgements

(TODO)


## Cite as

RA, 
Cell type deconvolution 
from bulk RNA-seq of the human brain,
December 2020,
[http://bit.ly/deco_ra](http://bit.ly/deco_ra).

***


```{r include=FALSE}
knitr::knit_exit()
```

## DWLS

```{r}
# https://github.com/dtsoucas/DWLS/blob/master/Manual.docx
BiocManager::install("MAST")
remotes::install_bitbucket("yuanlab/dwls")
requireNamespace("DWLS")
```

```{r}
x <- MAST::FromMatrix(
  exprsArray = as.matrix(darm_data),
  cData = darm_meta,
  class = "SingleCellAssay",
  check_sanity = FALSE
)

x <-
  DWLS::buildSignatureMatrixMAST(
    scdata = as.matrix(darm_data),
    id = setNames(as.list(darm_meta[["celltype"]]), rownames(darm_meta))
  )

require("ROCR")
require("MAST")
scdata_dummy <- matrix(sample.int(100, size = 4 * 15, replace = T), nrow = 5, ncol = 4)
rownames(scdata_dummy) <- paste("Gene", 1:nrow(scdata_dummy), sep = "")
colnames(scdata_dummy) <- paste("Cell", 1:ncol(scdata_dummy), sep = "")
y <- DWLS::DEAnalysisMAST(scdata = scdata_dummy, id = c("A", "B", "A", "B"), path = "./here.dat")
# Fails with:
#  Error in .subset2(x, i, exact = exact) : invalid subscript type 'S4'
```


[//]: # XX -- TODO

```{r, eval=FALSE, echo=FALSE}
library(SingleCellExperiment)
library(scater)
factor_name <- "Source"
fgcz_data %>%
  edgeR::cpm(.) %>%
  {
    (.)[abm1_markergenes, ]
  } %>%
  {
    list(logcounts = log(1 + .))
  } %>%
  SingleCellExperiment(assays = .) %>%
  scater::runMDS() %>%
  SingleCellExperiment::reducedDim() %>%
  as.data.frame() %>%
  setNames(c("x", "y")) %>%
  ggplot(aes(x = x, y = y, color = fgcz_meta[[factor_name]])) +
  labs(color = factor_name) +
  geom_point(size = 5)
```

```{r, eval=FALSE, echo=FALSE}
fgcz_abm1 %>%
  t() %>%
  as.data.frame() %>%
  dplyr::mutate(condition = fgcz_meta$Condition) %>%
  {
    MASS::lda(formula = condition ~ ., data = (.))
  }
```
